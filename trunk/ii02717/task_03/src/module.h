/**
 * @file module.h
 * @brief Заголовочный файл с функциями ПИД-регулятора и модели объекта
 * @author Соловчук И.Г. ИИ-27
 * @date 2025
 */

#ifndef MODULE_H
#define MODULE_H

#include <array>

/**
 * @brief Структура для хранения переменных состояния системы
 */
struct StateVariables {
    std::array<double, 3> y;    ///< Массив температур: y(k), y(k-1), y(k-2)
    std::array<double, 2> u;    ///< Массив управлений: u(k), u(k-1)
    double e_prev;              ///< Предыдущая ошибка регулирования
    double e_prev2;             ///< Предпредыдущая ошибка регулирования  
    double u_prev;              ///< Предыдущее управляющее воздействие
    double e_k;                 ///< Текущая ошибка регулирования
};

/**
 * @brief Расчет коэффициентов ПИД-регулятора для дискретной формы
 * @param K Коэффициент усиления объекта
 * @param T Постоянная времени объекта
 * @param Td Постоянная времени дифференцирования
 * @param T0 Время дискретизации
 * @param[out] q0 Выходной параметр: коэффициент q0
 * @param[out] q1 Выходной параметр: коэффициент q1  
 * @param[out] q2 Выходной параметр: коэффициент q2
 * 
 * Функция вычисляет коэффициенты ПИД-регулятора в дискретной форме
 * на основе параметров объекта и времени дискретизации.
 */
void calculatePidCoefficients(double K, double T, double Td, double T0, 
                             double& q0, double& q1, double& q2);

/**
 * @brief Расчет управляющего воздействия ПИД-регулятором
 * @param q0 Коэффициент q0 ПИД-регулятора
 * @param q1 Коэффициент q1 ПИД-регулятора
 * @param q2 Коэффициент q2 ПИД-регулятора
 * @param e_k Текущая ошибка регулирования
 * @param e_prev Ошибка на предыдущем шаге
 * @param e_prev2 Ошибка на предпредыдущем шаге
 * @param u_prev Управление на предыдущем шаге
 * @return Рассчитанное управляющее воздействие
 * 
 * Функция реализует алгоритм ПИД-регулятора в дискретной форме:
 * u(k) = u(k-1) + q0*e(k) + q1*e(k-1) + q2*e(k-2)
 */
double calculateControl(double q0, double q1, double q2,
                       double e_k, double e_prev, double e_prev2, 
                       double u_prev);

/**
 * @brief Применение ограничений к управляющему воздействию
 * @param u Рассчитанное управляющее воздействие
 * @return Управление с примененными ограничениями
 * 
 * Функция ограничивает управляющее воздействие в диапазоне [0, 100]
 * для предотвращения насыщения исполнительных механизмов.
 */
double applyControlLimits(double u);

/**
 * @brief Расчет нелинейной модели объекта управления
 * @param a Коэффициент a нелинейной модели
 * @param b Коэффициент b нелинейной модели
 * @param c Коэффициент c нелинейной модели
 * @param d Коэффициент d нелинейной модели
 * @param y1 Выход объекта на предыдущем шаге (y(k-1))
 * @param y0 Выход объекта на предпредыдущем шаге (y(k-2))
 * @param u1 Управление на предыдущем шаге (u(k-1))
 * @param u0 Управление на предпредыдущем шаге (u(k-2))
 * @return Текущее значение выхода объекта
 * 
 * Функция реализует нелинейную модель объекта вида:
 * y(k) = a*y(k-1) - b*y(k-2)^2 + c*u(k-1) + d*sin(u(k-2))
 */
double calculateNonlinearModel(double a, double b, double c, double d,
                             double y1, double y0, double u1, double u0);

/**
 * @brief Защита от отрицательной температуры
 * @param temperature Рассчитанная температура
 * @return Скорректированная температура
 * 
 * Функция обеспечивает защиту от физически некорректных 
 * отрицательных значений температуры, ограничивая снизу нулем.
 */
double applyTemperatureProtection(double temperature);

/**
 * @brief Расчет ошибки регулирования
 * @param setpoint Заданное значение (уставка)
 * @param current_value Текущее значение процесса
 * @return Ошибка регулирования
 * 
 * Функция вычисляет разность между заданным и текущим значением.
 * Для систем, где ошибка вычисляется иначе, требуется модификация.
 */
double calculateError(double setpoint, double current_value);

/**
 * @brief Обновление переменных состояния для следующей итерации
 * @param[in,out] state Структура с переменными состояния
 * 
 * Функция сдвигает массивы и переменные состояния для подготовки
 * к следующему шагу расчета, сохраняя историю значений.
 */
void updateStateVariables(StateVariables& state);

#endif